import { parseCidr } from 'cidr-tools';
import { stringifyIp } from 'ip-bigint';
import type { ClientType } from '#db/repositories/client/types';
import type { InterfaceType } from '#db/repositories/interface/types';
import type { UserConfigType } from '#db/repositories/userConfig/types';
import type { HooksType } from '#db/repositories/hooks/types';
import { exec } from './cmd';
import { iptablesTemplate } from './template';

type Options = {
  enableIpv6?: boolean;
};

export const wg = {
  generateServerPeer: (
    client: Omit<ClientType, 'createdAt' | 'updatedAt'>,
    options: Options = {}
  ) => {
    const { enableIpv6 = true } = options;

    const allowedIps = [
      `${client.ipv4Address}/32`,
      ...(enableIpv6 ? [`${client.ipv6Address}/128`] : []),
      ...(client.serverAllowedIps ?? []),
    ];

    const extraLines = [];
    if (client.serverEndpoint) {
      extraLines.push(`Endpoint = ${client.serverEndpoint}`);
    }

    return `# Client: ${client.name} (${client.id})
[Peer]
PublicKey = ${client.publicKey}
PresharedKey = ${client.preSharedKey}
AllowedIPs = ${allowedIps.join(', ')}${extraLines.length ? `\n${extraLines.join('\n')}` : ''}`;
  },

  generateServerInterface: (
    wgInterface: InterfaceType,
    hooks: HooksType,
    options: Options = {}
  ) => {
    const { enableIpv6 = true } = options;

    const cidr4 = parseCidr(wgInterface.ipv4Cidr);
    const cidr6 = parseCidr(wgInterface.ipv6Cidr);
    const ipv4Addr = stringifyIp({ number: cidr4.start + 1n, version: 4 });
    const ipv6Addr = stringifyIp({ number: cidr6.start + 1n, version: 6 });

    const address =
      `${ipv4Addr}/${cidr4.prefix}` +
      (enableIpv6 ? `, ${ipv6Addr}/${cidr6.prefix}` : '');

    return `# Note: Do not edit this file directly.
# Your changes will be overwritten!

# Server
[Interface]
PrivateKey = ${wgInterface.privateKey}
Address = ${address}
ListenPort = ${wgInterface.port}
MTU = ${wgInterface.mtu}
Jc = ${wgInterface.jc}
Jmin = ${wgInterface.jmin}
Jmax = ${wgInterface.jmax}
S1 = ${wgInterface.s1}
S2 = ${wgInterface.s2}
H1 = ${wgInterface.h1}
H2 = ${wgInterface.h2}
H3 = ${wgInterface.h3}
H4 = ${wgInterface.h4}
PreUp = ${iptablesTemplate(hooks.preUp, wgInterface)}
PostUp = ${iptablesTemplate(hooks.postUp, wgInterface)}
PreDown = ${iptablesTemplate(hooks.preDown, wgInterface)}
PostDown = ${iptablesTemplate(hooks.postDown, wgInterface)}`;
  },

  generateClientConfig: (
    wgInterface: InterfaceType,
    userConfig: UserConfigType,
    client: ClientType,
    options: Options = {}
  ) => {
    const { enableIpv6 = true } = options;

    const cidr4Block = parseCidr(wgInterface.ipv4Cidr).prefix;
    const cidr6Block = parseCidr(wgInterface.ipv6Cidr).prefix;

    const address =
      `${client.ipv4Address}/${cidr4Block}` +
      (enableIpv6 ? `, ${client.ipv6Address}/${cidr6Block}` : '');

    const hookLines = [
      client.preUp ? `PreUp = ${client.preUp}` : null,
      client.postUp ? `PostUp = ${client.postUp}` : null,
      client.preDown ? `PreDown = ${client.preDown}` : null,
      client.postDown ? `PostDown = ${client.postDown}` : null,
    ];

    const dnsServers = client.dns ?? userConfig.defaultDns;
    const dnsLine =
      dnsServers.length > 0 ? `DNS = ${dnsServers.join(', ')}` : null;

    // AmneziaWG parameters - use client override or interface default
    const amzLines = [
      `Jc = ${client.jc ?? wgInterface.jc}`,
      `Jmin = ${client.jmin ?? wgInterface.jmin}`,
      `Jmax = ${client.jmax ?? wgInterface.jmax}`,
      `S1 = ${client.s1 ?? wgInterface.s1}`,
      `S2 = ${client.s2 ?? wgInterface.s2}`,
      `H1 = ${client.h1 ?? wgInterface.h1}`,
      `H2 = ${client.h2 ?? wgInterface.h2}`,
      `H3 = ${client.h3 ?? wgInterface.h3}`,
      `H4 = ${client.h4 ?? wgInterface.h4}`,
    ];

    const extraLines = [dnsLine, ...hookLines, ...amzLines].filter((v) => v !== null);

    return `[Interface]
PrivateKey = ${client.privateKey}
Address = ${address}
MTU = ${client.mtu}
${extraLines.length ? `${extraLines.join('\n')}\n` : ''}
[Peer]
PublicKey = ${wgInterface.publicKey}
PresharedKey = ${client.preSharedKey}
AllowedIPs = ${(client.allowedIps ?? userConfig.defaultAllowedIps).join(', ')}
PersistentKeepalive = ${client.persistentKeepalive}
Endpoint = ${userConfig.host}:${userConfig.port}`;
  },

  generatePrivateKey: () => {
    return exec('awg genkey');
  },

  getPublicKey: (privateKey: string) => {
    return exec(`echo ${privateKey} | awg pubkey`, {
      log: 'echo ***hidden*** | awg pubkey',
    });
  },

  generatePreSharedKey: () => {
    return exec('awg genpsk');
  },

  up: (infName: string) => {
    return exec(`awg-quick up ${infName}`);
  },

  down: (infName: string) => {
    return exec(`awg-quick down ${infName}`);
  },

  restart: (infName: string) => {
    return exec(`awg-quick down ${infName}; awg-quick up ${infName}`);
  },

  sync: (infName: string) => {
    return exec(`awg syncconf ${infName} <(awg-quick strip ${infName})`).catch((err: any) => {
      // If the interface doesn't exist or isn't running, just log and continue
      if (
        err &&
        err.message &&
        (err.message.includes('Protocol not supported') ||
         err.message.includes('Unable to access interface') ||
         err.message.includes('No such device') ||
         err.message.includes('does not exist'))
      ) {
        // Interface not running, skip sync
        return '';
      }
      throw err;
    });
  },

  dump: async (infName: string) => {
    try {
      const rawDump = await exec(`awg show ${infName} dump`, {
        log: false,
      });

      type wgDumpLine = [
        string,
        string,
        string,
        string,
        string,
        string,
        string,
        string,
      ];

      return rawDump
        .trim()
        .split('\n')
        .slice(1)
        .map((line) => {
          const splitLines = line.split('\t');
          const [
            publicKey,
            preSharedKey,
            endpoint,
            allowedIps,
            latestHandshakeAt,
            transferRx,
            transferTx,
            persistentKeepalive,
          ] = splitLines as wgDumpLine;

          return {
            publicKey,
            preSharedKey,
            endpoint: endpoint === '(none)' ? null : endpoint,
            allowedIps,
            latestHandshakeAt:
              latestHandshakeAt === '0'
                ? null
                : new Date(parseInt(`${latestHandshakeAt}000`)),
            transferRx: parseInt(transferRx),
            transferTx: parseInt(transferTx),
            persistentKeepalive: persistentKeepalive,
          };
        });
    } catch (err: any) {
      // If the interface doesn't exist or isn't running, return empty array
      if (
        err &&
        err.message &&
        (err.message.includes('Protocol not supported') ||
         err.message.includes('Unable to access interface') ||
         err.message.includes('No such device') ||
         err.message.includes('does not exist'))
      ) {
        return [];
      }
      throw err;
    }
  },
};
